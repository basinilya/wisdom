What were the original principles behind Enterprise Java Beans?

The concept of “Distributed Objects”, which inspired EJB’s architecture, has been developed during the 90s. Back then, HTTP was in its infancy, the web was growing and there was no REST, XML, JSON and Javascript was a toy language. Developing distributed systems was a very hard problem, because there was a lot of different programming languages (even common languages like C++ had different compiler vendors and different standard libraries), different platforms and even differences in endianness was a problem. Most of the software was proprietary (and costly) and every software vendor had its own ideas on how communication between distributed systems should be.

Then, an organization called OMG promoted a standard called CORBA, which was intended to make a common architecture for distributed systems. CORBA stands for Common Object Request Broker Architecture and as the name says was a standard architecture for distributed systems. It was based on the idea of distributed objects, since object-oriented programming was becoming the main paradigm at the time. Each vendor would provide both a client and a server ORB, which consisted of a proxy on the client-side and a remote object on the server side. Since each remote object could be located on different machines, there was a location service, which allowed server objects to be registered an unregistered and then located by a client. Each object had a descriptive interface called IDL, which described a data format for remote method calls. There was a protocol called GIOP for message exchange between systems, which had a lot of information about how data should be encoded or decoded depending on the platform. And there was a myriad of extensions, for enabling transactions (2-phase commit and the like), security, clustering etc. CORBA failed because many vendors didn’t implement all CORBA’s specification and also because CORBA’s architecture was very complex.

Then came EJBs, which was considered an evolution on previous distributed object systems. First of all, it was written in Java, which could run on many different OSs, of different architecures; it supported a CORBA-like distributed communcation model, based on remote methods; it supported distributed transactions which was essential to many big enterprises at the time; and allowed to interface many different systems. Add to that the fact that software sold by different vendors such as IBM and Sun could finally talk to each other.

The earlier versions of the EJB standard, however, were very complex and soon many developers worldwide realized the distributed object model and its implementations had many shortcomings. Read the article: Errant Architectures. Soon came more lightweight architectures, such as Spring. HTTP became a mature and widely adopted protocol, so communication technologies were built on the top of it. Web Services, although also inspired on the CORBA architecture (SOAP once stood for Simple Object Access Protocol, with WSDL as an equivallent to IDL, UDDI to Location Services and WS-* was equivalent to CORBA’s extensions), was built on the concept of a simple language such as XML, as a interchangeable format that could be easily parsed by most major programming languages available. When the web became the lingua franca of distributed systems, even simpler architectures gained momentum, such as REST, which is built on top of HTTP verbs, URLs and hypermedia. And now there’s open source everywhere, with communities which always adopted and promoted common standards and practices.

It’s important that ideas brought by the CORBA standard are usually reused on today’s projects. Protocol Buffers, gRPC, Avro and Thrift are very similar to remote method calls, they use some language to describe interface similar to IDL and both client and server agree on a common serialization format. Location services are implemented by libraries such as Netflix Eureka or by middleware such as Zookeeper and Etcd. Meteor.js is almost a simpler reincarnation of EJBs in javascript and Node.js. It’s a indicative that implementations and technologies come and go, but concepts stay alive and are refined every day.




Enterprise IT departments had been running Transaction Processing systems since the mid 1960’s, typically on the CICS environment of mainframes. Real Transaction Processing is a very complicated problem, because you have to be able to recover if any computer involved in the transaction crashes in the middle of committing a change. You need checkpoint records stored on disk and the ability to recover when the computer comes back up and pick up where you left off. Initially EJB was created to add Java to the set of languages available to code business logic in existing TP systems. Not surprisingly, CICS became an EJB container. Traditionally the container presents a simplified context where the programmer doesn’t have to worry about threads even through the container is concurrently running many requests. So EJB was simplified to hide threading and concurrency and networking and just concentrate on the transaction.

Today people imagine that transaction consistency is a problem for the database system and drivers, but CICS started its existence creating transactions on ordinary flat files on disk where there was no database and it had to manage its own log files and do the post crash recovery itself. So “real transaction processing” containers do not depend on the transaction manager of a single database, but can handle consistency between different data in multiple databases and consistence with data in flat files on disk. This is seriously hard programming.

EJBs can contain “state” about the transaction. That is, they may hold data that must eventually be committed to the database. In a real EJB container, this means that in order for the container to recover across a crash and restart and reconnect to a transaction that spans multiple hosts, the container may have to periodically serialize stateful EJB objects to the checkpoint area of disk. That way after a crash and restart, the object can be restored to its previous content and continue to participate in the transaction. However, the programmer should know nothing about this and code the EJB as if the system could never crash.

Today EJBs have gone through many, many complete rewrites. It is no longer a major objective that EJBs allow Java code to coexist with non-Java code and the widely used current container are not as through about recovering from a complete crash in the middle of a transaction commit. But although they may no longer represent the thrust of EJB 4.0, those were the major design principles of the original EJB design.