Q: sleep
A: SELECT pg_sleep(10);

Q: insert default values
A: insert ... default values;

Q: suppress skipping message
A:
    SET client_min_messages TO WARNING;
    ... do stuff
    SET client_min_messages TO NOTICE;

Q: update from/update join
A: update mytable from tab1 A, tab2 B where mytable.x = A.x ...

Q: top/limit
A: ... limit 10;

Q: estimate number of rows in a table
A: SELECT relname, reltuples::BIGINT AS estimate FROM pg_class WHERE relname like '<table_name>';

Q:
A:
CREATE EXTENSION pg_trgm with schema pg_catalog;
create extension btree_gin with schema pg_catalog;
CREATE INDEX trgm_idx_users_username ON users USING gin (username gin_trgm_ops);
https://niallburkley.com/blog/index-columns-for-like-in-postgres/


Q: identity column
A: 
  use a sequence or a pseudo type SERIAL which is sugar for sequence

Q: rename column
A: alter table T rename C to C2;

Q: alter column
A: alter table T alter column C type ...; 

Q: long-running queries
A:
  SELECT
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query,
    state,
    waiting
  FROM pg_stat_activity
  WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';

-- cancel it
-- SELECT pg_cancel_backend(__pid__);

-- dangerous: kill it
-- SELECT pg_terminate_backend(__pid__);

Q: show server version
A: select version();

Q: restore search path
A: 
  When function created with the "proconfig":
    SET search_path TO ...
    or
    SET search_path TO FROM CURRENT
  the search path is restored when the function exits.
  However, even when the function has this proconfig,
  if "SET search_path" is called in the body, the search path is not restored


Q: current search path/current schema
A: select current_schema, current_schemas(false);

Q: set current schema
A:
  set search_path to spr_track, efxd;


Q: Port Oracle decode() to PostgreSQL
  
  desired:
    select xdecode(3.4, (1.2, now()),(3.4, now())], now());
    select xdecode(42, (1, 'x'),(42, 'y')], 'z');

A:
  Not possible.
  Use "case when". Caveat: NULL is a valid key in Oracle

  Ugly:
    select xdecode_ft(3.4, ARRAY[(1.2, now()),(3.4, now()) ]::pair_ft[], now());
    select xdecode_ic(42, ARRAY[(1, 'x'),(42, 'y') ]::pair_id[], 'z');


    create type pair_ft as ( k numeric, v timestamptz );

    create or replace function xdecode_ft(expr numeric, args pair_ft[], dflt timestamptz default null) RETURNS timestamptz AS $$
      select args[i].v from generate_subscripts(args,1) I(i) where (args[i].k = expr or args[i].k is null and expr is null)
      union all select dflt;
    $$ LANGUAGE sql;


Q: key/value pairs
A: hstore extension

Q: Pass generic RECORD to function
A: use LANGUAGE sql and anyelement/anyarray:

    create or replace function foo(variadic args anyarray) RETURNS text AS $$
      -- ...
    $$ LANGUAGE sql;

    select foo( (1,'a'),(2,'b') );
    select foo( (0.5,now()),(0.6,now()) );

Q: Extract data from a generic RECORD without knowing the column names
A:
   If types known, use a helper function:

    create or replace function hlp(arg anyelement) RETURNS record AS $$ select arg; $$ LANGUAGE sql;
    select a,b from hlp( myrec ) AS T(a int , b text);

   If types unknown, only row_to_json()
